
import multiprocessing as mp
import subprocess as sp
import os
import ctypes

from ..common import Cluster
from ..output import BaseOutput

abspath = os.path.abspath(__file__)
lib_path = os.path.join(os.path.dirname(abspath), '..', 'lib', 'libmain.dylib')


class BrutusInterface:
    """A Python interface to the Brutus integrator library. The interface
    provides methods to initialize a cluster, add stars to it, evolve the
    cluster, and clean up resources. The interface is implemented using
    ctypes to call functions in the Brutus library."""

    def __init__(self):
        self.lib = ctypes.CDLL(lib_path)

        self.seed_t = ctypes.c_char_p
        self.time_t = ctypes.c_double
        self.star_identifier_t = ctypes.c_int
        self.mass_t = ctypes.c_double
        self.position_t = ctypes.c_double * 3
        self.velocity_t = ctypes.c_double * 3

        self.lib.initCluster.argtypes = [self.seed_t]
        self.lib.addStar.argtypes = [self.star_identifier_t, self.mass_t, self.position_t, self.velocity_t]
        self.lib.evolve.argtypes = [self.time_t, self.time_t, ctypes.CFUNCTYPE(None, ctypes.c_char_p)]
        self.lib.cleanup.argtypes = None

        self.lib.initCluster.restype = None
        self.lib.addStar.restype = None
        self.lib.evolve.restype = None
        self.lib.cleanup.restype = None

    def init_cluster(self, seed: str):
        """Initialize a cluster with the given seed."""
        self.lib.initCluster(seed.encode("utf-8"))

    def add_star(self, identifier: int, mass: float, position: tuple, velocity: tuple):
        """Add a star to the cluster with the given mass, position, and velocity."""
        self.lib.addStar(identifier,
                         mass,
                         self.position_t(*position),
                         self.velocity_t(*velocity))
        
    def evolve(self, time: float, step_time: float, callback):
        """Evolve the cluster for the given time."""
        self.lib.evolve(time, step_time, callback)

    def cleanup(self):
        self.lib.cleanup()


class BrutusIntegrator:
    def __init__(self,
                 time_step: float,
                 *,
                 bulirsch_stoer_tolerance: float = 1e-11,
                 word_length: int = 128,
                 workers: int = 1):
        """Initialize the Brutus integrator.
        The default parameters are taken from the Newton vs. the Machine paper.

        Args:
            bulirsch_stoer_tolerance: The tolerance to use for the Bulirsch-Stoer integrator.
            word_length: The word length to use for the Bulirsch-Stoer integrator.
            workers: The number of workers to use for parallel processing. Each worker will run a separate simulation.
        """
        self.time_step = time_step
        self.bulirsch_stoer_tolerance = bulirsch_stoer_tolerance
        self.word_length = word_length

        self.workers = workers
        self.clusters = []
        self.output_handlers = []

    def add_cluster(self, cluster: Cluster, *, output_handler: BaseOutput | None = None):
        """Add a new star cluster.

        For each star cluster, a new Brutus process will be spawned to handle the simulation, which will be run in
        parallel with the other star clusters.

        Each star cluster will be simulated independently of the other star clusters and will generate its own output.

        Args:
            cluster: The star cluster to simulate.
            output_handler: The output handler to use for the simulation. If None, no output will be generated.
        """
        self.clusters.append(cluster)
        self.output_handlers.append(output_handler)

    def evolve(self, time: float):
        """Evolve the simulation until t = time.

        This will spawn a new process for each star cluster and run the simulation in parallel.

        Returns:
            A list of results for each star cluster. Each result is the output of the simulation, as generated by the
            output handler.
        """
        with mp.Pool(processes=self.workers) as pool:
            results = pool.starmap(self._simulate_cluster, [(cluster, time, output_handler) for cluster, output_handler in zip(self.clusters, self.output_handlers)])

        return results
    
    def _simulate_cluster(self, cluster: Cluster, time: float, output_handler: BaseOutput | None):
        @ctypes.CFUNCTYPE(None, ctypes.c_char_p)
        def callback(line: bytes):
            line = line.decode()

            if output_handler:
                output_handler.receive_output_line(line)
            
        interface = BrutusInterface()
        interface.init_cluster("seed")  # TODO: Add seed to Cluster

        for star in cluster.stars:
            interface.add_star(star.identifier, star.mass, star.position, star.velocity)

        interface.evolve(time, self.time_step, callback)

        interface.cleanup()

        if output_handler:
            output_handler.finalize()

        result = output_handler.result() if output_handler else None
        return result
